export const __webpack_esm_id__=134;export const __webpack_esm_ids__=[134];export const __webpack_esm_modules__={134:(e,t,n)=>{n.r(t),n.d(t,{default:()=>a});var o=n(156),i=n(361),s=n(62),r=n(469);const a=({effectOptions:e={onSpeedUp:()=>{},onSlowDown:()=>{},distortion:"turbulentDistortion",length:400,roadWidth:9,islandWidth:2,lanesPerRoad:3,fov:90,fovSpeedUp:150,speedUp:2,carLightsFade:.4,totalSideLightSticks:50,lightPairsPerRoadWay:50,shoulderLinesWidthPercentage:.05,brokenLinesWidthPercentage:.1,brokenLinesLengthPercentage:.5,lightStickWidth:[.12,.5],lightStickHeight:[1.3,1.7],movingAwaySpeed:[60,80],movingCloserSpeed:[-120,-160],carLightsLength:[20,60],carLightsRadius:[.05,.14],carWidthPercentage:[.3,.5],carShiftX:[-.2,.2],carFloorSeparation:[.05,1],colors:{roadColor:526344,islandColor:657930,background:0,shoulderLines:16777215,brokenLines:16777215,leftCars:[14177983,6770850,12732332],rightCars:[242627,941733,3294549],sticks:242627}}})=>{const t=(0,o.useRef)(null),n=(0,o.useRef)(null);return(0,o.useEffect)(()=>{if(n.current){n.current.dispose();const e=document.getElementById("lights");if(e)for(;e.firstChild;)e.removeChild(e.firstChild)}const t={uFreq:{value:new i.Pq0(3,6,10)},uAmp:{value:new i.Pq0(30,30,20)}},o={uFreq:{value:new i.I9Y(5,2)},uAmp:{value:new i.I9Y(25,15)}},a={uFreq:{value:new i.I9Y(2,3)},uAmp:{value:new i.I9Y(35,10)}},h={uFreq:{value:new i.IUQ(4,8,8,1)},uAmp:{value:new i.IUQ(25,5,10,10)}},u={uFreq:{value:new i.I9Y(4,8)},uAmp:{value:new i.I9Y(10,20)},uPowY:{value:new i.I9Y(20,2)}};let l=e=>.5*Math.sin(e)+.5;const d={mountainDistortion:{uniforms:t,getDistortion:"\n          uniform vec3 uAmp;\n          uniform vec3 uFreq;\n          #define PI 3.14159265358979\n          float nsin(float val){\n            return sin(val) * 0.5 + 0.5;\n          }\n          vec3 getDistortion(float progress){\n            float movementProgressFix = 0.02;\n            return vec3(\n              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n              nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n              nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n            );\n          }\n        ",getJS:(e,n)=>{let o=.02,s=t.uFreq.value,r=t.uAmp.value,a=new i.Pq0(Math.cos(e*Math.PI*s.x+n)*r.x-Math.cos(o*Math.PI*s.x+n)*r.x,l(e*Math.PI*s.y+n)*r.y-l(o*Math.PI*s.y+n)*r.y,l(e*Math.PI*s.z+n)*r.z-l(o*Math.PI*s.z+n)*r.z),h=new i.Pq0(2,2,2),u=new i.Pq0(0,0,-5);return a.multiply(h).add(u)}},xyDistortion:{uniforms:o,getDistortion:"\n          uniform vec2 uFreq;\n          uniform vec2 uAmp;\n          #define PI 3.14159265358979\n          vec3 getDistortion(float progress){\n            float movementProgressFix = 0.02;\n            return vec3(\n              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n              sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\n              0.\n            );\n          }\n        ",getJS:(e,t)=>{let n=o.uFreq.value,s=o.uAmp.value,r=new i.Pq0(Math.cos(e*Math.PI*n.x+t)*s.x-Math.cos(.02*Math.PI*n.x+t)*s.x,Math.sin(e*Math.PI*n.y+t+Math.PI/2)*s.y-Math.sin(.02*Math.PI*n.y+t+Math.PI/2)*s.y,0),a=new i.Pq0(2,.4,1),h=new i.Pq0(0,0,-3);return r.multiply(a).add(h)}},LongRaceDistortion:{uniforms:a,getDistortion:"\n          uniform vec2 uFreq;\n          uniform vec2 uAmp;\n          #define PI 3.14159265358979\n          vec3 getDistortion(float progress){\n            float camProgress = 0.0125;\n            return vec3(\n              sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\n              sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\n              0.\n            );\n          }\n        ",getJS:(e,t)=>{let n=.0125,o=a.uFreq.value,s=a.uAmp.value,r=new i.Pq0(Math.sin(e*Math.PI*o.x+t)*s.x-Math.sin(n*Math.PI*o.x+t)*s.x,Math.sin(e*Math.PI*o.y+t)*s.y-Math.sin(n*Math.PI*o.y+t)*s.y,0),h=new i.Pq0(1,1,0),u=new i.Pq0(0,0,-5);return r.multiply(h).add(u)}},turbulentDistortion:{uniforms:h,getDistortion:"\n          uniform vec4 uFreq;\n          uniform vec4 uAmp;\n          float nsin(float val){\n            return sin(val) * 0.5 + 0.5;\n          }\n          #define PI 3.14159265358979\n          float getDistortionX(float progress){\n            return (\n              cos(PI * progress * uFreq.r + uTime) * uAmp.r +\n              pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n            );\n          }\n          float getDistortionY(float progress){\n            return (\n              -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\n              -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n            );\n          }\n          vec3 getDistortion(float progress){\n            return vec3(\n              getDistortionX(progress) - getDistortionX(0.0125),\n              getDistortionY(progress) - getDistortionY(0.0125),\n              0.\n            );\n          }\n        ",getJS:(e,t)=>{const n=h.uFreq.value,o=h.uAmp.value,s=e=>Math.cos(Math.PI*e*n.x+t)*o.x+Math.pow(Math.cos(Math.PI*e*n.y+t*(n.y/n.x)),2)*o.y,r=e=>-l(Math.PI*e*n.z+t)*o.z-Math.pow(l(Math.PI*e*n.w+t/(n.z/n.w)),5)*o.w;let a=new i.Pq0(s(e)-s(e+.007),r(e)-r(e+.007),0),u=new i.Pq0(-2,-5,0),d=new i.Pq0(0,0,-10);return a.multiply(u).add(d)}},turbulentDistortionStill:{uniforms:h,getDistortion:"\n          uniform vec4 uFreq;\n          uniform vec4 uAmp;\n          float nsin(float val){\n            return sin(val) * 0.5 + 0.5;\n          }\n          #define PI 3.14159265358979\n          float getDistortionX(float progress){\n            return (\n              cos(PI * progress * uFreq.r) * uAmp.r +\n              pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n            );\n          }\n          float getDistortionY(float progress){\n            return (\n              -nsin(PI * progress * uFreq.b) * uAmp.b +\n              -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n            );\n          }\n          vec3 getDistortion(float progress){\n            return vec3(\n              getDistortionX(progress) - getDistortionX(0.02),\n              getDistortionY(progress) - getDistortionY(0.02),\n              0.\n            );\n          }\n        "},deepDistortionStill:{uniforms:u,getDistortion:"\n          uniform vec4 uFreq;\n          uniform vec4 uAmp;\n          uniform vec2 uPowY;\n          float nsin(float val){\n            return sin(val) * 0.5 + 0.5;\n          }\n          #define PI 3.14159265358979\n          float getDistortionX(float progress){\n            return (\n              sin(progress * PI * uFreq.x) * uAmp.x * 2.\n            );\n          }\n          float getDistortionY(float progress){\n            return (\n              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\n            );\n          }\n          vec3 getDistortion(float progress){\n            return vec3(\n              getDistortionX(progress) - getDistortionX(0.02),\n              getDistortionY(progress) - getDistortionY(0.05),\n              0.\n            );\n          }\n        "},deepDistortion:{uniforms:u,getDistortion:"\n          uniform vec4 uFreq;\n          uniform vec4 uAmp;\n          uniform vec2 uPowY;\n          float nsin(float val){\n            return sin(val) * 0.5 + 0.5;\n          }\n          #define PI 3.14159265358979\n          float getDistortionX(float progress){\n            return (\n              sin(progress * PI * uFreq.x + uTime) * uAmp.x\n            );\n          }\n          float getDistortionY(float progress){\n            return (\n              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n            );\n          }\n          vec3 getDistortion(float progress){\n            return vec3(\n              getDistortionX(progress) - getDistortionX(0.02),\n              getDistortionY(progress) - getDistortionY(0.02),\n              0.\n            );\n          }\n        ",getJS:(e,t)=>{const n=u.uFreq.value,o=u.uAmp.value,s=u.uPowY.value,r=e=>Math.sin(e*Math.PI*n.x+t)*o.x,a=e=>Math.pow(e*s.x,s.y)+Math.sin(e*Math.PI*n.y+t)*o.y;let h=new i.Pq0(r(e)-r(e+.01),a(e)-a(e+.01),0),l=new i.Pq0(-2,-4,0),d=new i.Pq0(0,0,-10);return h.multiply(l).add(d)}}};class c{constructor(e,t={}){this.options=t,null==this.options.distortion&&(this.options.distortion={uniforms:m,getDistortion:g}),this.container=e,this.renderer=new s.JeP({antialias:!1,alpha:!0}),this.renderer.setSize(e.offsetWidth,e.offsetHeight,!1),this.renderer.setPixelRatio(window.devicePixelRatio),this.composer=new r.s0(this.renderer),e.append(this.renderer.domElement),this.camera=new i.ubm(t.fov,e.offsetWidth/e.offsetHeight,.1,1e4),this.camera.position.z=-5,this.camera.position.y=8,this.camera.position.x=0,this.scene=new i.Z58,this.scene.background=null;let n=new i.jUj(t.colors.background,.2*t.length,500*t.length);this.scene.fog=n,this.fogUniforms={fogColor:{value:n.color},fogNear:{value:n.near},fogFar:{value:n.far}},this.clock=new i.zD7,this.assets={},this.disposed=!1,this.road=new F(this,t),this.leftCarLights=new P(this,t,t.colors.leftCars,t.movingAwaySpeed,new i.I9Y(0,1-t.carLightsFade)),this.rightCarLights=new P(this,t,t.colors.rightCars,t.movingCloserSpeed,new i.I9Y(1,0+t.carLightsFade)),this.leftSticks=new y(this,t),this.fovTarget=t.fov,this.speedUpTarget=0,this.speedUp=0,this.timeOffset=0,this.tick=this.tick.bind(this),this.init=this.init.bind(this),this.setSize=this.setSize.bind(this),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onContextMenu=this.onContextMenu.bind(this),window.addEventListener("resize",this.onWindowResize.bind(this))}onWindowResize(){const e=this.container.offsetWidth,t=this.container.offsetHeight;this.renderer.setSize(e,t),this.camera.aspect=e/t,this.camera.updateProjectionMatrix(),this.composer.setSize(e,t)}initPasses(){this.renderPass=new r.AH(this.scene,this.camera),this.bloomPass=new r.Vu(this.camera,new r.bv({luminanceThreshold:.2,luminanceSmoothing:0,resolutionScale:1}));const e=new r.Vu(this.camera,new r.eF({preset:r.MB.MEDIUM,searchImage:r.eF.searchImageDataURL,areaImage:r.eF.areaImageDataURL}));this.renderPass.renderToScreen=!1,this.bloomPass.renderToScreen=!1,e.renderToScreen=!0,this.composer.addPass(this.renderPass),this.composer.addPass(this.bloomPass),this.composer.addPass(e)}loadAssets(){const e=this.assets;return new Promise(t=>{const n=new i.KPJ(t),o=new Image,s=new Image;e.smaa={},o.addEventListener("load",function(){e.smaa.search=this,n.itemEnd("smaa-search")}),s.addEventListener("load",function(){e.smaa.area=this,n.itemEnd("smaa-area")}),n.itemStart("smaa-search"),n.itemStart("smaa-area"),o.src=r.eF.searchImageDataURL,s.src=r.eF.areaImageDataURL})}init(){this.initPasses();const e=this.options;this.road.init(),this.leftCarLights.init(),this.leftCarLights.mesh.position.setX(-e.roadWidth/2-e.islandWidth/2),this.rightCarLights.init(),this.rightCarLights.mesh.position.setX(e.roadWidth/2+e.islandWidth/2),this.leftSticks.init(),this.leftSticks.mesh.position.setX(-(e.roadWidth+e.islandWidth/2)),this.container.addEventListener("mousedown",this.onMouseDown),this.container.addEventListener("mouseup",this.onMouseUp),this.container.addEventListener("mouseout",this.onMouseUp),this.container.addEventListener("touchstart",this.onTouchStart,{passive:!0}),this.container.addEventListener("touchend",this.onTouchEnd,{passive:!0}),this.container.addEventListener("touchcancel",this.onTouchEnd,{passive:!0}),this.container.addEventListener("contextmenu",this.onContextMenu),this.tick()}onMouseDown(e){this.options.onSpeedUp&&this.options.onSpeedUp(e),this.fovTarget=this.options.fovSpeedUp,this.speedUpTarget=this.options.speedUp}onMouseUp(e){this.options.onSlowDown&&this.options.onSlowDown(e),this.fovTarget=this.options.fov,this.speedUpTarget=0}onTouchStart(e){this.options.onSpeedUp&&this.options.onSpeedUp(e),this.fovTarget=this.options.fovSpeedUp,this.speedUpTarget=this.options.speedUp}onTouchEnd(e){this.options.onSlowDown&&this.options.onSlowDown(e),this.fovTarget=this.options.fov,this.speedUpTarget=0}onContextMenu(e){e.preventDefault()}update(e){let t=Math.exp(60*Math.log2(.9)*e);this.speedUp+=v(this.speedUp,this.speedUpTarget,t,1e-5),this.timeOffset+=this.speedUp*e;let n=this.clock.elapsedTime+this.timeOffset;this.rightCarLights.update(n),this.leftCarLights.update(n),this.leftSticks.update(n),this.road.update(n);let o=!1,s=v(this.camera.fov,this.fovTarget,t);if(0!==s&&(this.camera.fov+=s*e*6,o=!0),this.options.distortion.getJS){const e=this.options.distortion.getJS(.025,n);this.camera.lookAt(new i.Pq0(this.camera.position.x+e.x,this.camera.position.y+e.y,this.camera.position.z+e.z)),o=!0}o&&this.camera.updateProjectionMatrix()}render(e){this.composer.render(e)}dispose(){this.disposed=!0,this.renderer&&this.renderer.dispose(),this.composer&&this.composer.dispose(),this.scene&&this.scene.clear(),window.removeEventListener("resize",this.onWindowResize.bind(this)),this.container&&(this.container.removeEventListener("mousedown",this.onMouseDown),this.container.removeEventListener("mouseup",this.onMouseUp),this.container.removeEventListener("mouseout",this.onMouseUp),this.container.removeEventListener("touchstart",this.onTouchStart),this.container.removeEventListener("touchend",this.onTouchEnd),this.container.removeEventListener("touchcancel",this.onTouchEnd),this.container.removeEventListener("contextmenu",this.onContextMenu))}setSize(e,t,n){this.composer.setSize(e,t,n)}tick(){if(this.disposed||!this)return;if(function(e,t){const n=e.domElement,o=n.clientWidth,i=n.clientHeight,s=n.width!==o||n.height!==i;return s&&t(o,i,!1),s}(this.renderer,this.setSize)){const e=this.renderer.domElement;this.camera.aspect=e.clientWidth/e.clientHeight,this.camera.updateProjectionMatrix()}const e=this.clock.getDelta();this.render(e),this.update(e),requestAnimationFrame(this.tick)}}const m={uDistortionX:{value:new i.I9Y(80,3)},uDistortionY:{value:new i.I9Y(-40,2.5)}},g="\n      #define PI 3.14159265358979\n      uniform vec2 uDistortionX;\n      uniform vec2 uDistortionY;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      vec3 getDistortion(float progress){\n        progress = clamp(progress, 0., 1.);\n        float xAmp = uDistortionX.r;\n        float xFreq = uDistortionX.g;\n        float yAmp = uDistortionY.r;\n        float yFreq = uDistortionY.g;\n        return vec3(\n          xAmp * nsin(progress * PI * xFreq - PI / 2.),\n          yAmp * nsin(progress * PI * yFreq - PI / 2.),\n          0.\n        );\n      }\n    ",p=e=>Array.isArray(e)?Math.random()*(e[1]-e[0])+e[0]:Math.random()*e,f=e=>Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e;function v(e,t,n=.1,o=.001){let i=(t-e)*n;return Math.abs(i)<o&&(i=t-e),i}class P{constructor(e,t,n,o,i){this.webgl=e,this.options=t,this.colors=n,this.speed=o,this.fade=i}init(){const e=this.options;let t=new i.VnP(new i.Pq0(0,0,0),new i.Pq0(0,0,-1)),n=new i.j6(t,40,1,8,!1),o=(new i.CmU).copy(n);o.instanceCount=2*e.lightPairsPerRoadWay;let s=e.roadWidth/e.lanesPerRoad,r=[],a=[],h=[],u=this.colors;u=Array.isArray(u)?u.map(e=>new i.Q1f(e)):new i.Q1f(u);for(let t=0;t<e.lightPairsPerRoadWay;t++){let n=p(e.carLightsRadius),o=p(e.carLightsLength),i=p(this.speed),l=t%e.lanesPerRoad*s-e.roadWidth/2+s/2,d=p(e.carWidthPercentage)*s;l+=p(e.carShiftX)*s;let c=p(e.carFloorSeparation)+1.3*n,m=-p(e.length);r.push(l-d/2),r.push(c),r.push(m),r.push(l+d/2),r.push(c),r.push(m),a.push(n),a.push(o),a.push(i),a.push(n),a.push(o),a.push(i);let g=f(u);h.push(g.r),h.push(g.g),h.push(g.b),h.push(g.r),h.push(g.g),h.push(g.b)}o.setAttribute("aOffset",new i.uWO(new Float32Array(r),3,!1)),o.setAttribute("aMetrics",new i.uWO(new Float32Array(a),3,!1)),o.setAttribute("aColor",new i.uWO(new Float32Array(h),3,!1));let l=new i.BKk({fragmentShader:w,vertexShader:x,transparent:!0,uniforms:Object.assign({uTime:{value:0},uTravelLength:{value:e.length},uFade:{value:this.fade}},this.webgl.fogUniforms,e.distortion.uniforms)});l.onBeforeCompile=t=>{t.vertexShader=t.vertexShader.replace("#include <getDistortion_vertex>",e.distortion.getDistortion)};let d=new i.eaF(o,l);d.frustumCulled=!1,this.webgl.scene.add(d),this.mesh=d}update(e){this.mesh.material.uniforms.uTime.value=e}}const w=`\n      #define USE_FOG;\n      ${s.vxI.fog_pars_fragment}\n      varying vec3 vColor;\n      varying vec2 vUv;\n      uniform vec2 uFade;\n      void main() {\n        vec3 color = vec3(vColor);\n        float alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n        gl_FragColor = vec4(color, alpha);\n        if (gl_FragColor.a < 0.0001) discard;\n        ${s.vxI.fog_fragment}\n      }\n    `,x=`\n      #define USE_FOG;\n      ${s.vxI.fog_pars_vertex}\n      attribute vec3 aOffset;\n      attribute vec3 aMetrics;\n      attribute vec3 aColor;\n      uniform float uTravelLength;\n      uniform float uTime;\n      varying vec2 vUv;\n      varying vec3 vColor;\n      #include <getDistortion_vertex>\n      void main() {\n        vec3 transformed = position.xyz;\n        float radius = aMetrics.r;\n        float myLength = aMetrics.g;\n        float speed = aMetrics.b;\n\n        transformed.xy *= radius;\n        transformed.z *= myLength;\n\n        transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);\n        transformed.xy += aOffset.xy;\n\n        float progress = abs(transformed.z / uTravelLength);\n        transformed.xyz += getDistortion(progress);\n\n        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n        gl_Position = projectionMatrix * mvPosition;\n        vUv = uv;\n        vColor = aColor;\n        ${s.vxI.fog_vertex}\n      }\n    `;class y{constructor(e,t){this.webgl=e,this.options=t}init(){const e=this.options,t=new i.bdM(1,1);let n=(new i.CmU).copy(t),o=e.totalSideLightSticks;n.instanceCount=o;let s=e.length/(o-1);const r=[],a=[],h=[];let u=e.colors.sticks;u=Array.isArray(u)?u.map(e=>new i.Q1f(e)):new i.Q1f(u);for(let t=0;t<o;t++){let n=p(e.lightStickWidth),o=p(e.lightStickHeight);r.push((t-1)*s*2+s*Math.random());let i=f(u);a.push(i.r),a.push(i.g),a.push(i.b),h.push(n),h.push(o)}n.setAttribute("aOffset",new i.uWO(new Float32Array(r),1,!1)),n.setAttribute("aColor",new i.uWO(new Float32Array(a),3,!1)),n.setAttribute("aMetrics",new i.uWO(new Float32Array(h),2,!1));const l=new i.BKk({fragmentShader:L,vertexShader:I,side:i.$EB,uniforms:Object.assign({uTravelLength:{value:e.length},uTime:{value:0}},this.webgl.fogUniforms,e.distortion.uniforms)});l.onBeforeCompile=t=>{t.vertexShader=t.vertexShader.replace("#include <getDistortion_vertex>",e.distortion.getDistortion)};const d=new i.eaF(n,l);d.frustumCulled=!1,this.webgl.scene.add(d),this.mesh=d}update(e){this.mesh.material.uniforms.uTime.value=e}}const I=`\n      #define USE_FOG;\n      ${s.vxI.fog_pars_vertex}\n      attribute float aOffset;\n      attribute vec3 aColor;\n      attribute vec2 aMetrics;\n      uniform float uTravelLength;\n      uniform float uTime;\n      varying vec3 vColor;\n      mat4 rotationY( in float angle ) {\n        return mat4(    cos(angle),        0,        sin(angle),    0,\n                     0,        1.0,             0,    0,\n                -sin(angle),    0,        cos(angle),    0,\n                0,         0,                0,    1);\n      }\n      #include <getDistortion_vertex>\n      void main(){\n        vec3 transformed = position.xyz;\n        float width = aMetrics.x;\n        float height = aMetrics.y;\n\n        transformed.xy *= vec2(width, height);\n        float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);\n\n        transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\n\n        transformed.z += - uTravelLength + time;\n\n        float progress = abs(transformed.z / uTravelLength);\n        transformed.xyz += getDistortion(progress);\n\n        transformed.y += height / 2.;\n        transformed.x += -width / 2.;\n        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n        gl_Position = projectionMatrix * mvPosition;\n        vColor = aColor;\n        ${s.vxI.fog_vertex}\n      }\n    `,L=`\n      #define USE_FOG;\n      ${s.vxI.fog_pars_fragment}\n      varying vec3 vColor;\n      void main(){\n        vec3 color = vec3(vColor);\n        gl_FragColor = vec4(color,1.);\n        ${s.vxI.fog_fragment}\n      }\n    `;class F{constructor(e,t){this.webgl=e,this.options=t,this.uTime={value:0}}createPlane(e,t,n){const o=this.options,s=new i.bdM(n?o.roadWidth:o.islandWidth,o.length,20,100);let r={uTravelLength:{value:o.length},uColor:{value:new i.Q1f(n?o.colors.roadColor:o.colors.islandColor)},uTime:this.uTime};n&&(r=Object.assign(r,{uLanes:{value:o.lanesPerRoad},uBrokenLinesColor:{value:new i.Q1f(o.colors.brokenLines)},uShoulderLinesColor:{value:new i.Q1f(o.colors.shoulderLines)},uShoulderLinesWidthPercentage:{value:o.shoulderLinesWidthPercentage},uBrokenLinesLengthPercentage:{value:o.brokenLinesLengthPercentage},uBrokenLinesWidthPercentage:{value:o.brokenLinesWidthPercentage}}));const a=new i.BKk({fragmentShader:n?S:D,vertexShader:b,side:i.$EB,uniforms:Object.assign(r,this.webgl.fogUniforms,o.distortion.uniforms)});a.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <getDistortion_vertex>",o.distortion.getDistortion)};const h=new i.eaF(s,a);return h.rotation.x=-Math.PI/2,h.position.z=-o.length/2,h.position.x+=(this.options.islandWidth/2+o.roadWidth/2)*e,this.webgl.scene.add(h),h}init(){this.leftRoadWay=this.createPlane(-1,this.options.roadWidth,!0),this.rightRoadWay=this.createPlane(1,this.options.roadWidth,!0),this.island=this.createPlane(0,this.options.islandWidth,!1)}update(e){this.uTime.value=e}}const M=`\n      #define USE_FOG;\n      varying vec2 vUv;\n      uniform vec3 uColor;\n      uniform float uTime;\n      #include <roadMarkings_vars>\n      ${s.vxI.fog_pars_fragment}\n      void main() {\n        vec2 uv = vUv;\n        vec3 color = vec3(uColor);\n        #include <roadMarkings_fragment>\n        gl_FragColor = vec4(color, 1.);\n        ${s.vxI.fog_fragment}\n      }\n    `,D=M.replace("#include <roadMarkings_fragment>","").replace("#include <roadMarkings_vars>",""),S=M.replace("#include <roadMarkings_fragment>","\n      uv.y = mod(uv.y + uTime * 0.05, 1.);\n      float laneWidth = 1.0 / uLanes;\n      float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\n      float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n      float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));\n      float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);\n\n      brokenLines = mix(brokenLines, sideLines, uv.x);\n    ").replace("#include <roadMarkings_vars>","\n      uniform float uLanes;\n      uniform vec3 uBrokenLinesColor;\n      uniform vec3 uShoulderLinesColor;\n      uniform float uShoulderLinesWidthPercentage;\n      uniform float uBrokenLinesWidthPercentage;\n      uniform float uBrokenLinesLengthPercentage;\n      highp float random(vec2 co) {\n        highp float a = 12.9898;\n        highp float b = 78.233;\n        highp float c = 43758.5453;\n        highp float dt = dot(co.xy, vec2(a, b));\n        highp float sn = mod(dt, 3.14);\n        return fract(sin(sn) * c);\n      }\n    "),b=`\n      #define USE_FOG;\n      uniform float uTime;\n      ${s.vxI.fog_pars_vertex}\n      uniform float uTravelLength;\n      varying vec2 vUv;\n      #include <getDistortion_vertex>\n      void main() {\n        vec3 transformed = position.xyz;\n        vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n        transformed.x += distortion.x;\n        transformed.z += distortion.y;\n        transformed.y += -1. * distortion.z;\n\n        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n        gl_Position = projectionMatrix * mvPosition;\n        vUv = uv;\n        ${s.vxI.fog_vertex}\n      }\n    `;return function(){const t=document.getElementById("lights"),o={...e};o.distortion=d[o.distortion];const i=new c(t,o);n.current=i,i.loadAssets().then(i.init)}(),()=>{n.current&&n.current.dispose()}},[e]),React.createElement("div",{id:"lights",ref:t})}}};